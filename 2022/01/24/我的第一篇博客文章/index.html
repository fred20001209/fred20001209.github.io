<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>我的第一篇博客文章 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Verilog HDL 基础一.Verilog 的基本概念1. 硬件描述语言HDL1.1 特点：    描述电路的连接、描述电路的功能、在不同抽象级上描述电路、    描述电路的时序、表达具有并行性 1.2  形式   Verilog  和   VHDL   2、自顶向下设计的基本概念 模块（module）是Verilog的基本描述单位，用于描述某个设计的功能或结构及与其他模块通信的外部端口。">
<meta property="og:type" content="article">
<meta property="og:title" content="我的第一篇博客文章">
<meta property="og:url" content="http://example.com/2022/01/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Verilog HDL 基础一.Verilog 的基本概念1. 硬件描述语言HDL1.1 特点：    描述电路的连接、描述电路的功能、在不同抽象级上描述电路、    描述电路的时序、表达具有并行性 1.2  形式   Verilog  和   VHDL   2、自顶向下设计的基本概念 模块（module）是Verilog的基本描述单位，用于描述某个设计的功能或结构及与其他模块通信的外部端口。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-e8a2f9944ddec6780092705e7a964635_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-54bd090f71a8ae36af8b0c2b78b3b799_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-63e08f3ba65742aca2a41f7253161101_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-9c0ea029b0d1332707b47a0837380301_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-7afb0c3056ada3da66aaf25f4262e656_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-7313e39967a0196f45ddbc0ec4fd6f25_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-ff1cf6ab07f2990099afdba2935c61b8_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-0ad157e7f97e55b0f97e294ac443298b_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-a28feb340f1470d8a1367021aaa1e6e5_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-d7122139ba21a90df6a3eb4e3b86ab42_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-d4a36ae623d13efbb4f4be0ba5b31609_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-53e4486abbd11d0eb9c69abd7e363b00_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-b136f99b0696cf0bf832dce9b1c1c20b_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-393b138502b9a58a08e464d54189e35a_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-3c5f1dbb0b5d707c388e55b5bb4412f9_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-fd2c231ad80b82071a4cfb8de8c75700_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-6cc2b400531b15d50b7a9913bef18888_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-1dc608ff7f1230c4ea140aca8cc363c0_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-223b1018e94087baec1dfb470a9f294f_720w.jpg">
<meta property="og:image" content="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-fbbcbef292296619818f392530cbf9bb_720w.jpg">
<meta property="article:published_time" content="2022-01-24T03:56:03.000Z">
<meta property="article:modified_time" content="2022-01-24T04:00:08.198Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Verilog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-e8a2f9944ddec6780092705e7a964635_720w.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-我的第一篇博客文章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" class="article-date">
  <time class="dt-published" datetime="2022-01-24T03:56:03.000Z" itemprop="datePublished">2022-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      我的第一篇博客文章
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Verilog-HDL-基础"><a href="#Verilog-HDL-基础" class="headerlink" title="Verilog HDL 基础"></a>Verilog HDL 基础</h1><h3 id="一-Verilog-的基本概念"><a href="#一-Verilog-的基本概念" class="headerlink" title="一.Verilog 的基本概念"></a>一.Verilog 的基本概念</h3><h5 id="1-硬件描述语言HDL"><a href="#1-硬件描述语言HDL" class="headerlink" title="1. 硬件描述语言HDL"></a>1. 硬件描述语言HDL</h5><p>1.1 特点：</p>
<p>   <em>描述电路的连接、描述电路的功能、在不同抽象级上描述电路、</em></p>
<p>   <em>描述电路的时序、表达具有并行性</em></p>
<p>1.2  形式</p>
<p>  <em>Verilog  和   VHDL</em>  </p>
<h5 id="2、自顶向下设计的基本概念"><a href="#2、自顶向下设计的基本概念" class="headerlink" title="2、自顶向下设计的基本概念"></a>2、自顶向下设计的基本概念</h5><ul>
<li><p>模块（module）是Verilog的基本描述单位，用于描述某个设计的功能或结构及与其他模块通信的外部端口。</p>
</li>
<li><p>模块内容是嵌在module和endmodule两个语句之间。每个模块实现特定的功能，模块可进行层次的嵌套，因此可以将大型的数字电路设计分割成大小不一的小模块来实现特定的功能，最后通过由顶层模块调用子模块来实现整体功能，这就是Top-Down的设计思想。</p>
</li>
</ul>
<h5 id="3-抽象级别"><a href="#3-抽象级别" class="headerlink" title="3.抽象级别"></a>3.抽象级别</h5><ol>
<li><p>系统级</p>
</li>
<li><p>算法级</p>
</li>
<li><p>==RTL级== ：描述数据在寄存器之间的流动和如何处理、控制这些数据流动的模型。</p>
<hr>
<p>以上三种都属于行为描述，只有RTL级才与逻辑电路有明确的对应关系。</p>
</li>
<li><p>==门级==  ：描述逻辑门以及逻辑门之间的连接的模型。</p>
</li>
<li><p>开关级</p>
</li>
</ol>
<h3 id="二-Verilog-的基本格式"><a href="#二-Verilog-的基本格式" class="headerlink" title="二.Verilog 的基本格式"></a>二.Verilog 的基本格式</h3><h5 id="1-示例1"><a href="#1-示例1" class="headerlink" title="1.示例1"></a>1.示例1</h5><p>多路选择器</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>  mux (out ,<span class="keyword">int</span> <span class="number">0</span>,<span class="keyword">int</span> <span class="number">1</span>,sel);</span><br><span class="line">      parametet N=<span class="number">8</span>;</span><br><span class="line">      <span class="keyword">output</span>  [N:<span class="number">1</span>]   out;</span><br><span class="line">      <span class="keyword">input</span> [N:<span class="number">1</span>]    in0,in1;</span><br><span class="line">      <span class="keyword">input</span>   sel;</span><br><span class="line">      <span class="keyword">assign</span> out=sel?in1:in0; <span class="comment">//描述组合电路</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h5 id="2-示例2"><a href="#2-示例2" class="headerlink" title="2.示例2"></a>2.示例2</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> count4(out,reset,clk);</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">input</span> reset,clk;  <span class="comment">//默认为wire型，描述组合逻辑</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] out;  <span class="comment">//数据类型定义：寄存器型(有保持功能)</span></span><br><span class="line"><span class="comment">//描述时序逻辑：</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="comment">//时钟上升沿执行下面语句块：描述时序</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (reset) </span><br><span class="line">                out&lt;=<span class="number">0</span>; <span class="comment">//同步复位</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                out&lt;=out+<span class="number">1&#x27;b1</span>; <span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>







<p>​    </p>
<h3 id="三-数据类型及常量、变量"><a href="#三-数据类型及常量、变量" class="headerlink" title="三.数据类型及常量、变量"></a>三.数据类型及常量、变量</h3><h5 id="1-常用词法"><a href="#1-常用词法" class="headerlink" title="1.常用词法"></a>1.常用词法</h5><ul>
<li>Verilog HDL区分大小写</li>
<li>Verilog HDL的关键字(如：always、and、input等) 都采用小写</li>
</ul>
<h5 id="2-常量之数字"><a href="#2-常量之数字" class="headerlink" title="2.常量之数字"></a>2.常量之数字</h5><p>   <strong>1.整数：</strong></p>
<ul>
<li><p>语法：&lt;位宽&gt; ^’^&lt;进制&gt; &lt;数值&gt;</p>
</li>
<li><p>形式：</p>
<ol>
<li>   二进制整数(b或B)</li>
</ol>
<ol start="2">
<li>十进制整数(d或D)</li>
<li>十六进制整数(h或H)</li>
<li>八进制整数(o或O)  </li>
</ol>
</li>
<li><p>表达方式有以下三种:</p>
</li>
</ul>
<ol>
<li><p>&lt;位宽&gt;&lt;进制&gt;&lt;数字&gt;这是一种全面的描述方式。</p>
</li>
<li><p>&lt;进制&gt;&lt;数字&gt;在这种描述方式中,数字的位宽采用缺省位宽(这由具体的机器系统决定,但至少32位)。</p>
</li>
<li><p>&lt;数字&gt;在这种描述方式中,采用缺省进制十进制。</p>
</li>
</ol>
<p>在表达式中,位宽指明了数字的精确位数。例如:一个4位二进制数的数字的位宽为4,一个4位十六进制数的数字的位宽为16(因为每单个十六进制数就要用4位二进制数来表示)。见下例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8&#x27;b10101100</span> <span class="comment">//位宽为8的数的二进制表示, &#x27;b表示二进制</span></span><br><span class="line"><span class="number">8&#x27;ha2</span> <span class="comment">//位宽为8的数的十六进制，&#x27;h表示十六进制。</span></span><br></pre></td></tr></table></figure>

<p>​    注意：</p>
<p>​        <strong>4’h1111</strong>实际表示4’b0001</p>
<p>  <strong>2.x和z值:</strong></p>
<p>在数字电路中,<strong>x</strong>代表不定值,<strong>z</strong>代表高阻值。</p>
<p>一个x可以用来定义十六进制数的四位二进制数的状态,八进制数的三位,二进制数的一位。</p>
<p><strong>z</strong>的表示方式同x类似。<strong>z</strong>还有一种表达方式是可以写作**?**。在使用case表达式时建议使用这种写法,以提高程序的可读性。见下例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b10x0</span> <span class="comment">//位宽为4的二进制数从低位数起第二位为不定值</span></span><br><span class="line"><span class="number">4&#x27;b101z</span> <span class="comment">//位宽为4的二进制数从低位数起第一位为高阻值</span></span><br><span class="line"><span class="number">12&#x27;dz</span> <span class="comment">//位宽为12的十进制数其值为高阻值(第一种表达方式)</span></span><br><span class="line"><span class="number">12</span>&#x27;d? <span class="comment">//位宽为12的十进制数其值为高阻值(第二种表达方式)</span></span><br><span class="line"><span class="number">8&#x27;h4x</span> <span class="comment">//位宽为8的十六进制数其低四位值为不定值</span></span><br></pre></td></tr></table></figure>

<p>  <strong>3.负数:</strong></p>
<p>一个数字可以被定义为负数,只需在位宽表达式前加一个减号,减号必须写在数字定义表达式的最前面。注意减号不可以放在位宽和进制之间也不可以放在进制和具体的数之间。见下例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">8&#x27;d5</span> <span class="comment">//这个表达式代表5的补数（用八位二进制数表示)</span></span><br><span class="line"><span class="number">8</span>&#x27;d-<span class="number">5</span> <span class="comment">//非法格式</span></span><br></pre></td></tr></table></figure>

<p> <strong>4.下划线(underscore_):</strong></p>
<p>下划线可以用来分隔开数的表达以提高程序可读性。但不可以用在位宽和进制处,只能用在具体的数字之间。见下例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16&#x27;b1010_1011_1111_1010</span>  <span class="comment">//合法格式</span></span><br><span class="line"><span class="number">8&#x27;b_0011_1010</span>  <span class="comment">//非法格式</span></span><br></pre></td></tr></table></figure>

<p>当常量不说明位数时，默认值是32位，每个字母用8位的ASCII值表示。</p>
<p>例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>＝<span class="number">32&#x27;d10</span>＝<span class="number">32&#x27;b1010</span></span><br><span class="line"><span class="number">1</span>=<span class="number">32&#x27;d1</span>=<span class="number">32&#x27;b1</span></span><br><span class="line">-<span class="number">1</span>=-<span class="number">32&#x27;d1</span>=<span class="number">32&#x27;hFFFFFFFF</span></span><br><span class="line">‘BX=<span class="number">32&#x27;BX</span>=<span class="number">32&#x27;BXXXXXXX</span>…X</span><br><span class="line">“AB”=<span class="number">16&#x27;B01000001_01000010</span></span><br></pre></td></tr></table></figure>

<h5 id="3-常量之参数"><a href="#3-常量之参数" class="headerlink" title="3.常量之参数"></a>3.常量之参数</h5><p>​    在Verilog HDL中用parameter来定义常量,即用parameter来定义一个标识符代表一个常量,称为符号常量,即标识符形式的常量,采用标识符代表一个常量可提高程序的可读性和可维护性。parameter型数据是一种常数型的数据，其说明格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> 参数名<span class="number">1</span>＝表达式，参数名<span class="number">2</span>＝表达式, …， 参数名n＝表达式;</span><br></pre></td></tr></table></figure>

<p>​    parameter是参数型数据的确认符，确认符后跟着一个用逗号分隔开的赋值语句表。在每一个赋值语句的右边必须是一个常数表达式。</p>
<p>​    也就是说，该表达式只能包含数字或先前已定义过的参数。见下列：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> msb=<span class="number">7</span>;  <span class="comment">//定义参数msb为常量7</span></span><br><span class="line"><span class="keyword">parameter</span> e=<span class="number">25</span>, f=<span class="number">29</span>; <span class="comment">//定义二个常数参数</span></span><br><span class="line"><span class="keyword">parameter</span> r=<span class="number">5</span><span class="variable">.7</span>;  <span class="comment">//声明r为一个实型参数</span></span><br><span class="line"><span class="keyword">parameter</span> byte_size=<span class="number">8</span>, byte_msb=byte_size-<span class="number">1</span>; <span class="comment">//用常数表达式赋值</span></span><br><span class="line"><span class="keyword">parameter</span> average_delay = (r+f)/<span class="number">2</span>;  <span class="comment">//用常数表达式赋值</span></span><br></pre></td></tr></table></figure>

<p>​     </p>
<h5 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h5><p>  <strong>一． wire型</strong></p>
<p><strong>wire型数据常用来表示用于以assign关键字指定的组合逻辑信号</strong>。Verilog程序模块中输入输出信号类型缺省时自动定义为wire型。wire型信号可以用作任何方程式的输入，也可以用作“assign”语句或实例元件的输出。</p>
<p>wire型信号的格式同reg型信号的很类似。其格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [n-<span class="number">1</span>:<span class="number">0</span>] 数据名<span class="number">1</span>,数据名<span class="number">2</span>,…数据名i; <span class="comment">//共有i条总线，每条总线内有n条线路 </span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [n:<span class="number">1</span>] 数据名<span class="number">1</span>,数据名<span class="number">2</span>,…数据名i; </span><br></pre></td></tr></table></figure>

<p>wire是wire型数据的确认符，**[n-1:0]和[n:1]代表该数据的位宽**，即该数据有几位。最后跟着的是数据的名字。如果一次定义多个数据，数据名之间用逗号隔开。声明语句的最后要用分号表示语句结束。看下面的几个例子。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> a; <span class="comment">//定义了一个一位的wire型数据</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] b; <span class="comment">//定义了一个八位的wire型数据</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">1</span>] c, d; <span class="comment">//定义了二个四位的wire型数据</span></span><br></pre></td></tr></table></figure>

<p>   <strong>二． reg型</strong></p>
<p><strong>寄存器是数据储存单元的抽象</strong>。寄存器数据类型的关键字是reg。通过赋值语句可以改变寄存器储存的值，其作用与改变触发器储存的值相当。</p>
<p>Verilog HDL语言提供了功能强大的结构语句使设计者能有效地控制是否执行这些赋值语句。这些控制结构用来描述硬件触发条件，例如时钟的上升沿和多路器的选通信号。reg类型数据的缺省初始值为不定值，x。</p>
<p>reg型数据常用来表示用于“always”模块内的指定信号，常<strong>代表触发器</strong>。通常，在设计中要由“always”块通过使用行为描述语句来表达逻辑关系。<strong>在“always”块内被赋值的每一个信号都必须定义成reg型。</strong></p>
<p>reg型数据的格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [n-<span class="number">1</span>:<span class="number">0</span>] 数据名<span class="number">1</span>,数据名<span class="number">2</span>,… 数据名i;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [n:<span class="number">1</span>]  数据名<span class="number">1</span>,数据名<span class="number">2</span>,… 数据名i;</span><br></pre></td></tr></table></figure>

<p>reg是reg型数据的确认标识符，[n-1:0]和[n:1]代表该数据的位宽，即该数据有几位（bit)。最后跟着的是数据的名字。如果一次定义多个数据，数据名之间用逗号隔开。声明语句的最后要用分号表示语句结束。看下面的几个例子：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> rega; <span class="comment">//定义了一个一位的名为rega的reg型数据</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]  regb; <span class="comment">//定义了一个四位的名为regb的reg型数据</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">1</span>] regc, regd; <span class="comment">//定义了两个四位的名为regc和regd的reg型数据</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] mymem[<span class="number">1023</span>:<span class="number">0</span>] <span class="comment">//定义1k字节的存储器</span></span><br></pre></td></tr></table></figure>

<p><strong>对于reg型数据，其赋值语句的作用就象改变一组触发器的存储单元的值</strong>。</p>
<p>在Verilog中有许多构造(construct)用来控制何时或是否执行这些赋值语句。这些控制构造可用来描述硬件触发器的各种具体情况，如触发条件用时钟的上升沿等，或用来描述具体判断逻辑的细节，如各种多路选择器。</p>
<p><strong>reg型数据的缺省初始值是不定值x。</strong>reg型数据可以赋正值，也可以赋负值。但当一个reg型数据是一个表达式中的操作数时，它的值被当作是无符号值，即正值。例如：当一个四位的寄存器用作表达式中的操作数时，如果开始寄存器被赋以值-1,则在表达式中进行运算时，其值被认为是+15。</p>
<p><strong>注意：</strong></p>
<p>reg型只表示被定义的信号将用在“always”块内，理解这一点很重要。并不是说reg型信号一定是寄存器或触发器的输出。虽然reg型信号常常是寄存器或触发器的输出，但并不一定总是这样。</p>
<p>初学者往往会对wire和reg的用法混淆，下面是对<strong>wire和reg用法的总结:</strong></p>
<p><em><strong>wire用法总结</strong></em></p>
<p>1.wire可以在Verilog中表示任意宽度的单线/总线</p>
<p>2.wire可以用于模块的输入和输出端口以及一些其他元素并在实际模块声明中</p>
<p>3.wire不能存储值（无状态），并且不能在always @块内赋值（=或&lt;=）左侧使用。</p>
<p>4.wire是assign语句左侧唯一的合法类型</p>
<p>5.wire只能用于组合逻辑</p>
<p><em><strong>reg用法总结</strong></em></p>
<ol>
<li><p>类似于电线，但可以存储信息（有内存，有状态）允许连接到模块的输入端口，但不能连接到实例化的输出</p>
</li>
<li><p>在模块声明中，reg可以用作输出，但不能用作输入</p>
</li>
<li><p>在always@(……)语句块内，= 或者 &lt;= 赋值语句的左边必须是是reg变量</p>
<p>在initial语句块内，= 赋值语句的左边必须是是reg变量</p>
</li>
<li><p>Reg不能用于assign赋值语句的左侧</p>
</li>
<li><p>当与@（posedge clock）块一起使用时，reg可用于创建寄存器</p>
</li>
<li><p>reg可用于组合逻辑和时序逻辑</p>
</li>
</ol>
<p><img src="https://pic2.zhimg.com/80/v2-e8a2f9944ddec6780092705e7a964635_720w.jpg" alt="img"></p>
<p><em><strong>构建一个模块module时</strong>，</em></p>
<p>​    input必须是wire</p>
<p>​    output可以是wire也可以是reg</p>
<p>​    inout必须是wire</p>
<p><em><strong>例化模块时</strong>，</em></p>
<p>​    外部连接input端口的可以是wire也可以是reg</p>
<p>​    外部连接output端口的必须是wire</p>
<p>​    外部连接inout端口的必须是wire</p>
<h3 id="四-运算符"><a href="#四-运算符" class="headerlink" title="四.运算符"></a>四.运算符</h3><p>Verilog HDL语言的运算符范围很广，其运算符<strong>按其功能可分为以下几类:</strong></p>
<ol>
<li><p>算术运算符(+,－,×，/,％)</p>
</li>
<li><p>赋值运算符(=,&lt;=)</p>
</li>
<li><p>关系运算符(&gt;,&lt;,&gt;=,&lt;=)</p>
</li>
<li><p>逻辑运算符(&amp;&amp;,||,!)</p>
</li>
<li><p>条件运算符(?:)</p>
</li>
<li><p>位运算符(<del>,|,^,&amp;,^</del>)</p>
</li>
<li><p>移位运算符(&lt;&lt;,&gt;&gt;)</p>
</li>
<li><p>拼接运算符({ })</p>
</li>
<li><p>其它</p>
</li>
</ol>
<p>在Verilog HDL语言中运算符所带的操作数是不同的，<strong>按其所带操作数的个数运算符可分为三种:</strong></p>
<ol>
<li><p>单目运算符(unary operator):可以带一个操作数,操作数放在运算符的右边。</p>
</li>
<li><p>二目运算符(binary operator):可以带二个操作数,操作数放在运算符的两边。</p>
</li>
<li><p>三目运算符(ternary operator):可以带三个操作,这三个操作数用三目运算符分隔开。</p>
</li>
</ol>
<p>见下例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clock = ~clock;  <span class="comment">// ~是一个单目取反运算符, clock是操作数。</span></span><br><span class="line">c = a | b;  <span class="comment">// 是一个二目按位或运算符, a 和 b是操作数。</span></span><br><span class="line">r = s ? t : u; <span class="comment">// ?: 是一个三目条件运算符, s,t,u是操作数。</span></span><br></pre></td></tr></table></figure>

<p>下面对常用的几种运算符进行介绍。</p>
<h5 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a><strong>1.算术运算符</strong></h5><p>在Verilog HDL语言中，算术运算符又称为二进制运算符，共有下面几种：</p>
<ol>
<li><p>+(加法运算符,或正值运算符,如 rega＋regb，＋3)</p>
</li>
<li><p>－ (减法运算符，或负值运算符，如 rega－3,－3)</p>
</li>
<li><p>× (乘法运算符，如rega*3)</p>
</li>
<li><p>/ (除法运算符，如5/3)</p>
</li>
<li><p>% (模运算符，或称为求余运算符，要求％两侧均为整型数据。如7％3的值为1)</p>
</li>
</ol>
<p>在进行整数除法运算时，结果值要略去小数部分，只取整数部分。而进行取模运算时，结果值的符号位采用模运算式里第一个操作数的符号位。见下例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">模运算表达式       结果     说明</span><br><span class="line">10%3               1       余数为1</span><br><span class="line">11%3               2       余数为2</span><br><span class="line">12%3               0       余数为0即无余数</span><br><span class="line">-10%3             -1       结果取第一个操作数的符号位,所以余数为-1</span><br><span class="line">11%3               2       结果取第一个操作数的符号位,所以余数为2.</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <strong>在进行算术运算操作时，如果某一个操作数有不确定的值x，则整个结果也为不定值x。</strong></p>
<h5 id="2-位运算符"><a href="#2-位运算符" class="headerlink" title="2.位运算符"></a><strong>2.位运算符</strong></h5><p>Verilog HDL作为一种硬件描述语言,是针对硬件电路而言的。在硬件电路中信号有四种状态值1,0,x,z.在电路中信号进行与或非时，反映在Verilog HDL中则是相应的操作数的位运算。Verilog HDL提供了以下五种位运算符：</p>
<ol>
<li><p>~     //取反</p>
</li>
<li><p>&amp;    //按位与</p>
</li>
<li><p>|    //按位或</p>
</li>
<li><p>^    //按位异或</p>
</li>
<li><p>^~  //按位同或(异或非)</p>
</li>
</ol>
<p>说明:</p>
<ul>
<li>位运算符中除了~是单目运算符以外,均为二目运算符,即要求运算符两侧各有一个操作数.</li>
<li>位运算符中的二目运算符要求对两个操作数的相应位进行运算操作。</li>
</ul>
<p>下面对各运算符分别进行介绍:</p>
<p><strong>1)</strong> <strong>“取反”运算符~</strong></p>
<p>~是一个单目运算符,用来对一个操作数进行按位取反运算。</p>
<p>其运算规则见下表:</p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-54bd090f71a8ae36af8b0c2b78b3b799_720w.jpg" alt="img"></p>
<p>举例说明:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rega=<span class="number">&#x27;b1010</span>;<span class="comment">//rega的初值为&#x27;b1010</span></span><br><span class="line">rega=~rega;<span class="comment">//rega的值进行取反运算后变为&#x27;b0101</span></span><br></pre></td></tr></table></figure>

<p><strong>2)</strong> <strong>“按位与”运算符&amp;</strong></p>
<p>按位与运算就是将两个操作数的相应位进行与运算,</p>
<p>其运算规则见下表:</p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-63e08f3ba65742aca2a41f7253161101_720w.jpg" alt="img"></p>
<p><strong>3)</strong> <strong>“按位或”运算符|</strong></p>
<p>按位或运算就是将两个操作数的相应位进行或运算。</p>
<p>其运算规则见下表:</p>
<p><img src="https://pic2.zhimg.com/80/v2-9c0ea029b0d1332707b47a0837380301_720w.jpg" alt="img"></p>
<p><strong>4)</strong> <strong>“按位异或”运算符^(也称之为XOR运算符)</strong></p>
<p>按位异或运算就是将两个操作数的相应位进行异或运算。</p>
<p>其运算规则见下表:</p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-7afb0c3056ada3da66aaf25f4262e656_720w.jpg" alt="img"></p>
<p><strong>5)</strong> <strong>“按位同或”运算符^~</strong></p>
<p>按位同或运算就是将两个操作数的相应位先进行异或运算再进行非运算.</p>
<p>其运算规则见下表:</p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-7313e39967a0196f45ddbc0ec4fd6f25_720w.jpg" alt="img"></p>
<p><strong>6)</strong> <strong>不同长度的数据进行位运算</strong></p>
<p>两个长度不同的数据进行位运算时,*<strong>系统会自动的将两者按右端对齐.位数少的操作数会在相应的高位用0填满,以使两个操作数按位进行操作.*</strong></p>
<h5 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3 逻辑运算符"></a><strong>3</strong> <strong>逻辑运算符</strong></h5><p>在Verilog HDL语言中存在三种逻辑运算符:</p>
<ol>
<li><p>&amp;&amp; 逻辑与</p>
</li>
<li><p>|| 逻辑或</p>
</li>
<li><p>! 逻辑非</p>
</li>
</ol>
<p>“&amp;&amp;”和”||”是二目运算符,它要求有两个操作数,如(a&gt;b)&amp;&amp;(b&gt;c),(a&lt;b)||(b&lt;c)。</p>
<p>“!”是单目运算符,只要求一个操作数,如!(a&gt;b)。</p>
<p>下表为逻辑运算的真值表。它表示当a和b的值为不同的组合时,各种逻辑运算所得到的值。</p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-ff1cf6ab07f2990099afdba2935c61b8_720w.jpg" alt="img"></p>
<p>逻辑运算符中”&amp;&amp;”和”||”的优先级别低于关系运算符,”!” 高于算术运算符。见下例:</p>
<ul>
<li>(a&gt;b)&amp;&amp;(x&gt;y) 可写成: a&gt;b &amp;&amp; x&gt;y</li>
<li>(a==b)||(x==y) 可写成:a==b || x==y</li>
<li>(!a)||(a&gt;b) 可写成: !a || a&gt;b</li>
</ul>
<p><strong>为了提高程序的可读性,明确表达各运算符间的优先关系,建议使用括号.</strong></p>
<h5 id="4-关系运算符"><a href="#4-关系运算符" class="headerlink" title="4.关系运算符"></a><strong>4.关系运算符</strong></h5><p>关系运算符共有以下四种：</p>
<p>a &lt; b a小于b</p>
<p>a &gt; b a大于b</p>
<p>a &lt;= b a小于或等于b</p>
<p>a &gt;= b a大于或等于b</p>
<p><strong>在进行关系运算时，如果声明的关系是假的(flase)，则返回值是0，如果声明的关系是真的(true)，则返回值是1，如果某个操作数的值不定，则关系是模糊的，返回值是不定值。</strong></p>
<p>所有的关系运算符有着相同的优先级别。关系运算符的优先级别低于算术运算符的优先级别。见下例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &lt; size-<span class="number">1</span> <span class="comment">//这种表达方式等同于下面</span></span><br><span class="line">a &lt; (size-<span class="number">1</span>) <span class="comment">//这种表达方式。</span></span><br><span class="line">size - ( <span class="number">1</span> &lt; a ) <span class="comment">//这种表达方式不等同于下面</span></span><br><span class="line">size - <span class="number">1</span> &lt; a <span class="comment">//这种表达方式。</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出这两种不同运算符的优先级别。当表达式size－(1&lt;a)进行运算时，关系表达式先被运算，然后返回结果值0或1被size减去。而当表达式 size－1&lt;a 进行运算时，size先被减去1，然后再同a相比。</p>
<h5 id="5-等式运算符"><a href="#5-等式运算符" class="headerlink" title="5.等式运算符"></a><strong>5.等式运算符</strong></h5><p>在Verilog HDL语言中存在四种等式运算符:</p>
<ol>
<li><p>== (等于)</p>
</li>
<li><p>!= (不等于)</p>
</li>
<li><p>=== (等于)</p>
</li>
<li><p>!== (不等于)</p>
</li>
</ol>
<p>这四个运算符都是二目运算符,它要求有两个操作数。”==”和”!=”又称为逻辑等式运算符。其结果由两个操作数的值决定。由于操作数中某些位可能是不定值x和高阻值z,结果可能为不定值x。</p>
<p><strong>而”===”和”!==”运算符则不同,它在对操作数进行比较时对某些位的不定值x和高阻值z也进行比较,两个操作数必需完全一致，其结果才是1，否则为0*。*</strong>“===”和”!==”运算符常用于case表达式的判别,所以又称为”case等式运算符”。这四个等式运算符的优先级别是相同的。下面画出＝＝与＝＝＝的真值表，帮助理解两者间的区别。</p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-0ad157e7f97e55b0f97e294ac443298b_720w.jpg" alt="img"></p>
<p>下面举一个例子说明“＝＝”和“＝＝＝”的区别。</p>
<p>例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(A==<span class="number">1</span>’bx) <span class="built_in">$display</span>(“AisX”); (当A等于X时，这个语句不执行)</span><br><span class="line"><span class="keyword">if</span>(A===<span class="number">1</span>’bx) <span class="built_in">$display</span>(“AisX”); (当A等于X时，这个语句执行)</span><br></pre></td></tr></table></figure>

<h5 id="6-移位运算符"><a href="#6-移位运算符" class="headerlink" title="6.移位运算符"></a><strong>6.移位运算符</strong></h5><p>在Verilog HDL中有两种移位运算符：</p>
<p>&lt;&lt; (左移位运算符) 和 &gt;&gt;(右移位运算符)。</p>
<p>其使用方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &gt;&gt; n;<span class="comment">//a右移n位</span></span><br><span class="line">a &lt;&lt; n;<span class="comment">//a左移n位</span></span><br></pre></td></tr></table></figure>

<p>a代表要进行移位的操作数，n代表要移几位。这两种移位运算都用0来填补移出的空位。下面举例说明:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shift;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] start, result;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        start = <span class="number">1</span>; <span class="comment">//start在初始时刻设为值0001</span></span><br><span class="line">        result = (start&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//移位后，start的值0100，然后赋给result。</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出，start在移过两位以后，用0来填补空出的位。</p>
<p>进行移位运算时应注意移位前后变量的位数，下面将给出一例。</p>
<p>例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>’b1001&lt;&lt;<span class="number">1</span> = <span class="number">5</span>’b10010; </span><br><span class="line"><span class="number">4</span>’b1001&lt;&lt;<span class="number">2</span> = <span class="number">6</span>’b100100;</span><br><span class="line"><span class="number">1</span>&lt;&lt;<span class="number">6</span> = <span class="number">32</span>’b1000000; </span><br><span class="line"><span class="number">4</span>’b1001&gt;&gt;<span class="number">1</span> = <span class="number">4</span>’b0100; </span><br><span class="line"><span class="number">4</span>’b1001&gt;&gt;<span class="number">4</span> = <span class="number">4</span>’b0000; </span><br></pre></td></tr></table></figure>

<h5 id="7-位拼接运算符-Concatation"><a href="#7-位拼接运算符-Concatation" class="headerlink" title="7.位拼接运算符(Concatation)"></a><strong>7.位拼接运算符(Concatation)</strong></h5><p>在Verilog HDL语言有一个特殊的运算符：<strong>位拼接</strong>运算符{}。用这个运算符可以把两个或多个信号的某些位拼接起来进行运算操作。其使用方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;信号<span class="number">1</span>的某几位，信号<span class="number">2</span>的某几位，..,..,信号n的某几位&#125;</span><br></pre></td></tr></table></figure>

<p>即把某些信号的某些位详细地列出来，中间用逗号分开，最后用大括号括起来表示一个整体信号。见下例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a,b[<span class="number">3</span>:<span class="number">0</span>],w,<span class="number">3</span>’b101&#125;</span><br></pre></td></tr></table></figure>

<p>也可以写成为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a,b[<span class="number">3</span>],b[<span class="number">2</span>],b[<span class="number">1</span>],b[<span class="number">0</span>],w,<span class="number">1</span>’b1,<span class="number">1</span>’b0,<span class="number">1</span>’b1&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在位拼接表达式中不允许存在没有指明位数的信号</strong>。这是因为在计算拼接信号的位宽的大小时必需知道其中每个信号的位宽。</p>
<p>位拼接还可以用重复法来简化表达式。见下例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">4</span>&#123;w&#125;&#125; <span class="comment">//这等同于&#123;w,w,w,w&#125;</span></span><br></pre></td></tr></table></figure>

<p>位拼接还可以用嵌套的方式来表达。见下例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;b,&#123;<span class="number">3</span>&#123;a,b&#125;&#125;&#125; <span class="comment">//这等同于&#123;b,a,b,a,b,a,b&#125;</span></span><br></pre></td></tr></table></figure>

<p>用于表示重复的表达式如上例中的4和3，必须是常数表达式。</p>
<p>补：</p>
<p>1.截取数据的不同位数进行拼接：</p>
<p>例：data1 = 0100_1101</p>
<p>data2 = 1011_0011</p>
<p>data = {data1[3:0],data2[7:4]}</p>
<p>则可得：data = 1101_1011</p>
<p>2.作为移位运算符使用，即在一个数据中对不同的位进行拼接，可以实现移位的作用：</p>
<p>这里需要补充一下移位运算符的用法：</p>
<p>左移：&lt;&lt;       右移：&gt;&gt;</p>
<p>在使用移位运算符时，无论是有符号还是无符号类型，移位出现的空缺一律用0填补，但是当进行的操作数和结果数位数不一致时，二者有明显的差异：</p>
<p>无符号类型：当操作数和结果数不一致时，需要在高位填0后，再进行移位；</p>
<p>有符号类型：当操作数和结果数不一致时，需要在高位填补符号位后，再进行移位。</p>
<p>对于移位运算符，要根据具体的电路去截取不同的位数，这里举一个例子：</p>
<p>data = 0011_0101</p>
<p>data1 = {1’b0,data[7:1]},则data1 = 0001_1010</p>
<p>data2 = (data &gt;&gt; 1),则data2 = 0001_1010</p>
<p>二者实现的效果是一致的。</p>
<h5 id="8-缩减运算符-reduction-operator"><a href="#8-缩减运算符-reduction-operator" class="headerlink" title="8.缩减运算符(reduction operator)"></a><strong>8.缩减运算符(reduction operator)</strong></h5><p><strong>缩减运算符是单目运算符,也有与或非运算</strong>。</p>
<p>其与或非运算规则类似于位运算符的与或非运算规则,但其运算过程不同。位运算是对操作数的相应位进行与或非运算,操作数是几位数则运算结果也是几位数。</p>
<p>而缩减运算则不同,缩减运算是对单个操作数进行或与非递推运算,最后的运算结果是一位的二进制数。</p>
<p>缩减运算的具体运算过程是这样的:第一步先将操作数的第一位与第二位进行或与非运算,第二步将运算结果与第三位进行或与非运算,依次类推,直至最后一位。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] B;</span><br><span class="line"><span class="keyword">reg</span> C;</span><br><span class="line">C = &amp;B;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C =( (B[<span class="number">0</span>]&amp;B[<span class="number">1</span>]) &amp; B[<span class="number">2</span>] ) &amp; B[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>由于缩减运算的与、或、非运算规则类似于位运算符与、或、非运算规则,这里不再详细讲述,请参照位运算符的运算规则介绍。</p>
<h3 id="五-语句"><a href="#五-语句" class="headerlink" title="五.语句"></a>五.语句</h3><table>
<thead>
<tr>
<th align="center"><strong>赋值语句</strong></th>
<th align="center"><strong>连续赋值语句</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"><strong>过程赋值语句</strong></td>
</tr>
<tr>
<td align="center"><strong>条件语句</strong></td>
<td align="center"><strong>if-else 语句</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><strong>case 语句</strong></td>
</tr>
<tr>
<td align="center"><strong>循环语句</strong></td>
<td align="center"><strong>forever 语句</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><strong>repeat 语句</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><strong>while 语句</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><strong>for 语句</strong></td>
</tr>
<tr>
<td align="center"><strong>结构说明语句</strong></td>
<td align="center"><strong>initial 语句</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><strong>always 语句</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><strong>task 语句</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><strong>function 语句</strong></td>
</tr>
<tr>
<td align="center"><strong>编译预处理语句</strong></td>
<td align="center"><strong>define 语句</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><strong>include 语句</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><strong>timescale 语句</strong></td>
</tr>
</tbody></table>
<h5 id="1-赋值语句"><a href="#1-赋值语句" class="headerlink" title="1.赋值语句"></a>1.赋值语句</h5><p>  1.1  连续赋值语句(assign) :常用于对wire型变量赋值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> a,b;</span><br><span class="line"><span class="keyword">output</span> c;</span><br><span class="line"><span class="keyword">assign</span> c=a&amp;b;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>  1.2  过程赋值语句：常用于对reg型变量进行赋值</p>
<p><strong>(1).非阻塞(Non_Blocking)赋值方式( 如 b &lt;= a;)</strong></p>
<ul>
<li><p>块结束后才完成赋值操作。</p>
</li>
<li><p>b的值并不是立刻就改变的。</p>
</li>
<li><p>这是一种比较常用的赋值方法。（特别在编写可综合模块时）</p>
</li>
<li><p>一条非阻塞赋值语句的执行是不会阻塞下一条语句的执行，并行执行。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> non_block(c,a,b,clk);</span><br><span class="line">   <span class="keyword">output</span> c,b;</span><br><span class="line">   <span class="keyword">input</span> a,clk;</span><br><span class="line">   <span class="keyword">reg</span> c,b;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">      <span class="keyword">begin</span> </span><br><span class="line">          b&lt;=a;   <span class="comment">//b的值变为a</span></span><br><span class="line">          c&lt;=b;   <span class="comment">//c的值为b的旧值</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>(2).阻塞(Blocking)赋值方式( 如 b = a; )</strong></p>
<ul>
<li><p>赋值语句执行完后,块才结束。</p>
</li>
<li><p>b的值在赋值语句执行完后立刻就改变的。</p>
</li>
<li><p>可能会产生意想不到的结果。</p>
</li>
<li><p>该语句结束时就完成赋值操作，前面的语句没有完成前，后面的语句不能执行，多个阻塞赋值语句是顺序执行的。</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> block(c,a,b,clk);</span><br><span class="line">   <span class="keyword">output</span> c,b;</span><br><span class="line">   <span class="keyword">input</span> a,clk;</span><br><span class="line">   <span class="keyword">reg</span> c,b;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">      <span class="keyword">begin</span> </span><br><span class="line">          b=a;   <span class="comment">//b的值变为a</span></span><br><span class="line">          c=b;   <span class="comment">//c的值变为b</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>





<h5 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2.条件语句"></a>2.条件语句</h5><h6 id="1-1-if-else语句"><a href="#1-1-if-else语句" class="headerlink" title="1.1 if_else语句"></a><strong>1.1 if_else语句</strong></h6><p>if语句是用来判定所给定的条件是否满足，根据判定的结果（真或假)决定执行给出的两种操作之一。Verilog HDL语言提供了三种形式的if语句。</p>
<p><strong>(1). if(表达式)语句</strong></p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a &gt; b ) </span><br><span class="line">   out1 &lt;= int1;</span><br></pre></td></tr></table></figure>

<p><strong>(2).if(表达式) 语句1</strong></p>
<p><strong>else 语句2</strong></p>
<p>例如： </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a&gt;b) </span><br><span class="line">    out1&lt;=int1;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    out1&lt;=int2;</span><br></pre></td></tr></table></figure>

<p><strong>(3).if(表达式1) 语句1;</strong></p>
<p><strong>else if(表达式2) 语句2;</strong></p>
<p><strong>else if(表达式3) 语句3;</strong></p>
<p><strong>……..</strong></p>
<p><strong>else if(表达式m) 语句m;</strong></p>
<p><strong>else 语句n;</strong></p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a&gt;b) out1&lt;=int1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==b) out1&lt;=int2;</span><br><span class="line"><span class="keyword">else</span> out1&lt;=int3;</span><br></pre></td></tr></table></figure>

<p><strong>六点说明：</strong></p>
<p>(1).三种形式的if语句中在if后面都有“表达式”，一般为逻辑表达式或关系表达式。系统对表达式的值进行判断，<strong>若为0,x,z，按“假”处理，若为1，按“真”处理</strong>，执行指定的语句。</p>
<p>(2) .第二、第三种形式的if语句中，在每个else前面有一分号，整个语句结束处有一分号。</p>
<p>例如：</p>
<p><img src="https://pic2.zhimg.com/80/v2-a28feb340f1470d8a1367021aaa1e6e5_720w.jpg" alt="img"></p>
<p>这是由于分号是Verilog HDL语句中不可缺少的部分，这个分号是if语句中的内嵌套语句所要求的。如果无此分号，则出现语法错误。但应注意，不要误认为上面是两个语句（if语句和else语句)。它们都属于同一个if语句。else子句不能作为语句单独使用，它必须是if语句的一部分，与if配对使用。</p>
<p>(3).在if和else后面可以包含一个内嵌的操作语句(如上例)，也可以有多个操作语句，此时用begin和end这两个关键词将几个语句包含起来成为一个复合块语句。如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a&gt;b)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">     out1&lt;=int1;</span><br><span class="line">     out2&lt;=int2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">     out1&lt;=int2;</span><br><span class="line">     out2&lt;=int1;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>注意在end后不需要再加分号。因为begin_end内是一个完整的复合语句，不需再附加分号。</p>
<p>(4).允许一定形式的表达式简写方式。如下面的例子：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expression) 等同与 <span class="keyword">if</span>( expression == <span class="number">1</span> )</span><br><span class="line"><span class="keyword">if</span>(！expression) 等同与 <span class="keyword">if</span>( expression != <span class="number">1</span> )</span><br></pre></td></tr></table></figure>

<p>(5).if语句的嵌套</p>
<p>在if语句中又包含一个或多个if语句称为if语句的嵌套。一般形式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expression1)</span><br><span class="line">    <span class="keyword">if</span>(expression2) 语句<span class="number">1</span> (内嵌<span class="keyword">if</span>)</span><br><span class="line">    <span class="keyword">else</span> 语句<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(expression3) 语句<span class="number">3</span> (内嵌<span class="keyword">if</span>)</span><br><span class="line">    <span class="keyword">else</span> 语句<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>应当注意if与else的配对关系，else总是与它上面的最近的if配对。如果if与else的数目不一样,为了实现程序设计者的企图,可以用begin_end块语句来确定配对关系。例如:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( )</span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">if</span>( ) 语句<span class="number">1</span> (内嵌<span class="keyword">if</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这时begin_end块语句限定了内嵌if语句的范围，因此else与第一个if配对。注意begin_end块语句在if_else语句中的使用。因为有时begin_end块语句的不慎使用会改变逻辑行为。见下例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(index&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(scani=<span class="number">0</span>;scani&lt;index;scani=scani+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(memory[scani]&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                memory[scani]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/*WRONG*/</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;error-indexiszero&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>尽管程序设计者把else写在与第一个if(外层if)同一列上，希望与第一个if对应，但实际上else是与第二个if对应，因为它们相距最近。正确的写法应当是这样的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(index&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span>(scani=<span class="number">0</span>;scani&lt;index;scani=scani+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(memory[scani]&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                memory[scani]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="comment">/*WRONG*/</span></span><br><span class="line"> <span class="built_in">$display</span>(<span class="string">&quot;error-indexiszero&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>(6).if_else例子</p>
<p>下面的例子是取自某程序中的一部分。这部分程序用if_else语句来检测变量index以决定三个寄存器modify_segn中哪一个的值应当与index相加作为memory的寻址地址。并且将相加值存入寄存器index以备下次检测使用。程序的前十行定义寄存器和参数。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//定义寄存器和参数。</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] instruction, segment_area[<span class="number">255</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] index;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] modify_seg1, modify_seg2, modify_seg3;</span><br><span class="line"><span class="keyword">parameter</span></span><br><span class="line">    segment1=<span class="number">0</span>, inc_seg1=<span class="number">1</span>,</span><br><span class="line">    segment2=<span class="number">20</span>, inc_seg2=<span class="number">2</span>,</span><br><span class="line">    segment3=<span class="number">64</span>, inc_seg3=<span class="number">4</span>,</span><br><span class="line">    data=<span class="number">128</span>;</span><br><span class="line"><span class="comment">//检测寄存器index的值</span></span><br><span class="line"><span class="keyword">if</span>(index&lt;segment2)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        instruction = segment_area[index + modify_seg1];</span><br><span class="line">        index = index + inc_seg1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(index&lt;segment3)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        instruction = segment_area[index + modify_seg2];</span><br><span class="line">        index = index + inc_seg2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (index&lt;data)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">       instruction = segment_area[index + modify_seg3]; </span><br><span class="line">       index = index + inc_seg3;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">instruction = segment_area[index];</span><br></pre></td></tr></table></figure>

<h6 id="1-2-case语句"><a href="#1-2-case语句" class="headerlink" title="1.2 case语句"></a><strong>1.2 case语句</strong></h6><p>case语句是一种多分支选择语句，if语句只有两个分支可供选择，而实际问题中常常需要用到多分支选择，Verilog语言提供的case语句直接处理多分支选择。它的一般形式如下:</p>
<ol>
<li><p><strong>case</strong>(表达式) &lt;case分支项&gt; endcase</p>
</li>
<li><p><strong>casez</strong>(表达式) &lt;case分支项&gt; endcase</p>
</li>
<li><p><strong>casex</strong>(表达式) &lt;case分支项&gt; endcase</p>
</li>
</ol>
<p>case分支项的一般格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分支表达式:         语句</span><br><span class="line">缺省项(default项):  语句</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>a) case括弧内的表达式称为控制表达式，case分支项中的表达式称为分支表达式。控制表达式通常表示为控制信号的某些位，分支表达式则用这些控制信号的具体状态值来表示，因此分支表达式又可以称为常量表达式。</p>
<p>b) 当控制表达式的值与分支表达式的值相等时，就执行分支表达式后面的语句。如果所有的分支表达式的值都没有与控制表达式的值相匹配的，就执行default后面的语句。</p>
<p>c) default项可有可无，一个case语句里只准有一个default项。</p>
<p>下面是一个简单的使用case语句的例子。该例子中对寄存器rega译码以确定result的值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] rega;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">9</span>:<span class="number">0</span>] result;</span><br><span class="line"><span class="keyword">case</span>(rega)</span><br><span class="line"><span class="number">16</span> <span class="number">&#x27;d0</span>: result = <span class="number">10</span> <span class="number">&#x27;b0111111111</span>;</span><br><span class="line"><span class="number">16</span> <span class="number">&#x27;d1</span>: result = <span class="number">10</span> <span class="number">&#x27;b1011111111</span>;</span><br><span class="line"><span class="number">16</span> <span class="number">&#x27;d2</span>: result = <span class="number">10</span> <span class="number">&#x27;b1101111111</span>;</span><br><span class="line"><span class="number">16</span> <span class="number">&#x27;d3</span>: result = <span class="number">10</span> <span class="number">&#x27;b1110111111</span>;</span><br><span class="line"><span class="number">16</span> <span class="number">&#x27;d4</span>: result = <span class="number">10</span> <span class="number">&#x27;b1111011111</span>;</span><br><span class="line"><span class="number">16</span> <span class="number">&#x27;d5</span>: result = <span class="number">10</span> <span class="number">&#x27;b1111101111</span>;</span><br><span class="line"><span class="number">16</span> <span class="number">&#x27;d6</span>: result = <span class="number">10</span> <span class="number">&#x27;b1111110111</span>;</span><br><span class="line"><span class="number">16</span> <span class="number">&#x27;d7</span>: result = <span class="number">10</span> <span class="number">&#x27;b1111111011</span>;</span><br><span class="line"><span class="number">16</span> <span class="number">&#x27;d8</span>: result = <span class="number">10</span> <span class="number">&#x27;b1111111101</span>;</span><br><span class="line"><span class="number">16</span> <span class="number">&#x27;d9</span>: result = <span class="number">10</span> <span class="number">&#x27;b1111111110</span>;</span><br><span class="line"><span class="keyword">default</span>： result = <span class="number">&#x27;bx</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p>d) 每一个case分项的分支表达式的值必须互不相同，否则就会出现矛盾现象(对表达式的同一个值，有多种执行方案)。</p>
<p>e) 执行完case分项后的语句，则跳出该case语句结构，终止case语句的执行。</p>
<p>f) 在用case语句表达式进行比较的过程中，只有当信号的对应位的值能明确进行比较时，比较才能成功。因此要注意详细说明case分项的分支表达式的值。</p>
<p>g) case语句的所有表达式的值的位宽必须相等，只有这样控制表达式和分支表达式才能进行对应位的比较。*<strong>一个经常犯的错误是用’bx, ‘bz 来替代 n’bx, n’bz，这样写是不对的，因为信号x, z的缺省宽度是机器的字节宽度，通常是32位(此处 n 是case控制表达式的位宽)。*</strong></p>
<p>下面将给出 <strong>case, casez, casex</strong> 的真值表：</p>
<p><img src="https://pic3.zhimg.com/80/v2-d7122139ba21a90df6a3eb4e3b86ab42_720w.jpg" alt="img"></p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-d4a36ae623d13efbb4f4be0ba5b31609_720w.jpg" alt="img"></p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-53e4486abbd11d0eb9c69abd7e363b00_720w.jpg" alt="img"></p>
<p><strong>case语句与if_else_if语句的区别主要有两点:</strong></p>
<ol>
<li><p>与case语句中的控制表达式和多分支表达式这种比较结构相比，if_else_if结构中的条件表达式更为直观一些。</p>
</li>
<li><p>对于那些分支表达式中存在不定值x和高阻值z位时,case语句提供了处理这种情况的手段。下面的两个例子介绍了处理x,z值位的case语句。</p>
</li>
</ol>
<p>[例1]:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ( select[<span class="number">1</span>:<span class="number">2</span>] )</span><br><span class="line"><span class="number">2</span> <span class="number">&#x27;b00</span>: result = <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span> <span class="number">&#x27;b01</span>: result = flaga;</span><br><span class="line"><span class="number">2</span> <span class="number">&#x27;b0x</span>,</span><br><span class="line"><span class="number">2</span> <span class="number">&#x27;b0z</span>: result = flaga? <span class="number">&#x27;bx</span> : <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span> <span class="number">&#x27;b10</span>: result = flagb;</span><br><span class="line"><span class="number">2</span> <span class="number">&#x27;bx0</span>,</span><br><span class="line"><span class="number">2</span> <span class="number">&#x27;bz0</span>: result = flagb? <span class="number">&#x27;bx</span> : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>: result = <span class="number">&#x27;bx</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p>[例2]:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span>(sig)</span><br><span class="line"><span class="number">1</span> <span class="number">&#x27;bz</span>: <span class="built_in">$display</span>(<span class="string">&quot;signal is floating&quot;</span>);</span><br><span class="line"><span class="number">1</span> <span class="number">&#x27;bx</span>: <span class="built_in">$display</span>(<span class="string">&quot;signal is unknown&quot;</span>);</span><br><span class="line"><span class="keyword">default</span>:  <span class="built_in">$display</span>(<span class="string">&quot;signal is %b&quot;</span>, sig);</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p>Verilog HDL针对电路的特性提供了case语句的其它两种形式用来处理case语句比较过程中的不必考虑的情况( don’t care condition )。其中casez语句用来处理不考虑高阻值z的比较过程，casex语句则将高阻值z和不定值都视为不必关心的情况。所谓不必关心的情况，即在表达式进行比较时，不将该位的状态考虑在内。这样在case语句表达式进行比较时，就可以灵活地设置以对信号的某些位进行比较。见下面的两个例子:</p>
<p>[例3]:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] ir;</span><br><span class="line"><span class="keyword">casez</span>(ir)</span><br><span class="line"> <span class="number">8</span> <span class="number">&#x27;b1</span>???????: instruction1(ir);</span><br><span class="line"> <span class="number">8</span> <span class="number">&#x27;b01</span>??????: instruction2(ir);</span><br><span class="line"> <span class="number">8</span> <span class="number">&#x27;b00010</span>???: instruction3(ir);</span><br><span class="line"> <span class="number">8</span> <span class="number">&#x27;b000001</span>??: instruction4(ir);</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p>[例4]:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] r, mask;</span><br><span class="line">mask = <span class="number">8&#x27;bx0x0x0x0</span>;</span><br><span class="line"><span class="keyword">casex</span>(r^mask)</span><br><span class="line"> <span class="number">8</span> <span class="number">&#x27;b001100xx</span>: stat1;</span><br><span class="line"> <span class="number">8</span> <span class="number">&#x27;b1100xx00</span>: stat2;</span><br><span class="line"> <span class="number">8</span> <span class="number">&#x27;b00xx0011</span>: stat3;</span><br><span class="line"> <span class="number">8</span> <span class="number">&#x27;bxx001100</span>: stat4;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p><strong>注：由于使用条件语句不当在设计中生成了原本没想到有的锁存器</strong></p>
<p>Verilog HDL设计中容易犯的一个通病是由于不正确使用语言，<strong>生成了并不想要的锁存器</strong>。下面我们给出了一个在“<strong>always”块中不正确使用if语句</strong>，造成这种错误的例子。</p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-b136f99b0696cf0bf832dce9b1c1c20b_720w.jpg" alt="img"></p>
<p>检查一下左边的”always”块，if语句保证了只有当al=1时，q才取d的值。这段程序没有写出 al = 0 时的结果, 那么当al=0时会怎么样呢？</p>
<p>在”always”块内，如果在给定的条件下变量没有赋值，这个变量将保持原值，也就是说会生成一个锁存器！</p>
<p>如果设计人员希望当 al = 0 时q的值为0，else项就必不可少了，请注意看右边的”always”块，整个Verilog程序模块综合出来后，”always”块对应的部分不会生成锁存器。</p>
<p><strong>Verilog HDL程序另一种偶然生成锁存器是在使用case语句时缺少default项的情况下发生的。</strong></p>
<p>case语句的功能是：在某个信号（本例中的sel)取不同的值时，给另一个信号（本例中的q)赋不同的值。</p>
<p>注意看下图左边的例子，如果sel=00,q取a值，而sel=11,q取b的值。这个例子中不清楚的是：如果sel取00和11以外的值时q将被赋予什么值？在下面左边的这个例子中，程序是用Verilog HDL写的，即默认为q保持原值，这就会自动生成锁存器。</p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-393b138502b9a58a08e464d54189e35a_720w.jpg" alt="img"></p>
<p>右边的例子很明确，程序中的case语句有default项，指明了如果sel不取00或11时，编译器或仿真器应赋给q的值。程序所示情况下，q赋为0,因此不需要锁存器。</p>
<p>以上就是怎样来避免<strong>偶然生成锁存器的错误。</strong></p>
<ul>
<li><strong>如果用到if语句，最好写上else项。</strong></li>
<li><strong>如果用case语句，最好写上default项。</strong></li>
</ul>
<p><strong>遵循上面两条原则，就可以避免发生这种错误，使设计者更加明确设计目标，同时也增强了Verilog程序的可读性。</strong></p>
<h5 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3.循环语句"></a>3.循环语句</h5><p>在Verilog HDL中存在着<strong>四种类型的循环语句</strong>，用来控制执行语句的执行次数。</p>
<ol>
<li><p><strong>forever</strong> 连续的执行语句。</p>
</li>
<li><p><strong>repeat</strong> 连续执行一条语句 n 次。</p>
</li>
<li><p><strong>while</strong> 执行一条语句直到某个条件不满足。如果一开始条件即不满足(为假)，则语句一次也不能被执行。</p>
</li>
<li><p><strong>for</strong>通过以下三个步骤来决定语句的循环执行。</p>
</li>
</ol>
<ul>
<li>a) 先给控制循环次数的变量赋初值。</li>
<li>b) 判定控制循环的表达式的值，如为假则跳出循环语句，如为真则执行指定的语句后，转到第三步。</li>
<li>c) 执行一条赋值语句来修正控制循环变量次数的变量的值，然后返回第二步。</li>
</ul>
<p>下面对各种循环语句详细的进行介绍。</p>
<h6 id="1-1forever语句"><a href="#1-1forever语句" class="headerlink" title="1.1forever语句"></a><strong>1.1forever语句</strong></h6><p>forever语句的格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">forever</span> 语句; </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">forever</span> </span><br><span class="line">   <span class="keyword">begin</span> </span><br><span class="line">   多条语句 </span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>forever循环语句常用于产生周期性的波形，用来作为仿真测试信号。它与always语句不同处在于不能独立写在程序中，而必须写在initial块中。</strong></p>
<h6 id="1-2-repeat语句"><a href="#1-2-repeat语句" class="headerlink" title="1.2 repeat语句"></a>1.2 repeat语句</h6><p>repeat语句的格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span>(表达式) 语句；</span><br><span class="line"> </span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span>(表达式) </span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">    多条语句 </span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>在repeat语句中，其表达式通常为常量表达式。</strong></p>
<p>下面的例子中使用repeat循环语句及加法和移位操作来实现一个乘法器。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> size=<span class="number">8</span>,longsize=<span class="number">16</span>;</span><br><span class="line"><span class="keyword">reg</span> [size:<span class="number">1</span>] opa, opb;</span><br><span class="line"><span class="keyword">reg</span> [longsize:<span class="number">1</span>] result;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">begin</span>: mult</span><br><span class="line"><span class="keyword">reg</span> [longsize:<span class="number">1</span>] shift_opa, shift_opb；</span><br><span class="line">shift_opa = opa;</span><br><span class="line">shift_opb = opb;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span>(size)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(shift_opb[<span class="number">1</span>])</span><br><span class="line">            result = result + shift_opa; </span><br><span class="line">            shift_opa = shift_opa &lt;&lt;<span class="number">1</span>;</span><br><span class="line">            shift_opb = shift_opb &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h6 id="1-3-while语句"><a href="#1-3-while语句" class="headerlink" title="1.3 while语句"></a>1.<strong>3 while语句</strong></h6><p>while语句的格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式) 语句</span><br></pre></td></tr></table></figure>

<p>或用如下格式：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式) </span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">    多条语句 </span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>下面举一个while语句的例子，该例子用while循环语句对rega这个八位二进制数中值为1的位进行计数。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>: count1s</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] tempreg;</span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line">tempreg = rega;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(tempreg)</span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">       <span class="keyword">if</span>(tempreg[<span class="number">0</span>]) count = count + <span class="number">1</span>;</span><br><span class="line">       tempreg = tempreg&gt;&gt;<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h6 id="1-4-for语句"><a href="#1-4-for语句" class="headerlink" title="1.4 for语句"></a>1.<strong>4 for语句</strong></h6><p>for语句的一般形式为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（表达式<span class="number">1</span>；表达式<span class="number">2</span>；表达式<span class="number">3</span>)  语句</span><br></pre></td></tr></table></figure>

<p>它的执行过程如下：</p>
<ol>
<li><p>先求解表达式1；</p>
</li>
<li><p>求解表达式2，若其值为真（非0)，则执行for语句中指定的内嵌语句，然后执行下面的第3步。若为假(0)，则结束循环，转到第5步。</p>
</li>
<li><p>若表达式为真，在执行指定的语句后，求解表达式3。</p>
</li>
<li><p>转回上面的第2步骤继续执行。</p>
</li>
<li><p>执行for语句下面的语句。</p>
</li>
</ol>
<p>for语句最简单的应用形式是很易理解的，其形式如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环变量赋初值；循环结束条件；循环变量增值)</span><br><span class="line">   执行语句</span><br></pre></td></tr></table></figure>

<p>for循环语句实际上相当于采用while循环语句建立以下的循环结构：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">    循环变量赋初值；</span><br><span class="line">    <span class="keyword">while</span>(循环结束条件)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            执行语句</span><br><span class="line">            循环变量增值;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这样对于需要8条语句才能完成的一个循环控制，for循环语句只需两条即可。</p>
<p>下面分别举两个使用for循环语句的例子。例1用for语句来初始化memory。例2则用for循环语句来实现前面用repeat语句实现的乘法器。</p>
<p>[例1]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>: init_mem</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] tempi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(tempi=<span class="number">0</span>;tempi&lt;memsize;tempi=tempi+<span class="number">1</span>)</span><br><span class="line">memory[tempi]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>[例2]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> size = <span class="number">8</span>, longsize = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">reg</span>[size:<span class="number">1</span>] opa, opb;</span><br><span class="line"><span class="keyword">reg</span>[longsize:<span class="number">1</span>] result;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">begin</span>:mult</span><br><span class="line"><span class="keyword">integer</span> bindex;</span><br><span class="line">result=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( bindex=<span class="number">1</span>; bindex&lt;=size; bindex=bindex+<span class="number">1</span> )</span><br><span class="line">    <span class="keyword">if</span>(opb[bindex])</span><br><span class="line">    result = result + (opa&lt;&lt;(bindex-<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在for语句中，循环变量增值表达式可以不必是一般的常规加法或减法表达式。下面是对rega这个八位二进制数中值为1的位进行计数的另一种方法。见下例：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>: count1s</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] tempreg;</span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( tempreg=rega; tempreg; tempreg=tempreg&gt;&gt;<span class="number">1</span> )</span><br><span class="line">        <span class="keyword">if</span>(tempreg[<span class="number">0</span>]) </span><br><span class="line">            count=count+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<h5 id="4-结构说明语句"><a href="#4-结构说明语句" class="headerlink" title="4.结构说明语句"></a>4.结构说明语句</h5><p>==过程块是行为模型的基础。==</p>
<p><strong>过程块有两种：</strong></p>
<ul>
<li><em>initial块，只能执行一次</em></li>
<li><em>always块，循环执行</em></li>
</ul>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-3c5f1dbb0b5d707c388e55b5bb4412f9_720w.jpg" alt="img"></p>
<p><strong>过程块中有下列部件：</strong></p>
<ul>
<li><em>过程赋值语句：在描述过程块中的数据流</em></li>
<li><em>高级结构（循环，条件语句）：描述块的功能</em></li>
<li><em>时序控制：控制块的执行及块中的语句。</em></li>
</ul>
<p><strong>initial</strong>语句与<strong>always</strong>语句和<strong>begin_end</strong>与<strong>fork_join</strong>是一种高频搭配：</p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-fd2c231ad80b82071a4cfb8de8c75700_720w.jpg" alt="img"></p>
<h6 id="1-1-initial语句"><a href="#1-1-initial语句" class="headerlink" title="1.1 initial语句"></a><strong>1.1 initial语句</strong></h6><p>initial语句的格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        ......</span><br><span class="line">        语句n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>举例说明：</p>
<p>[例1]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        areg=<span class="number">0</span>; <span class="comment">//初始化寄存器areg</span></span><br><span class="line">        <span class="keyword">for</span>(index=<span class="number">0</span>;index&lt;size;index=index+<span class="number">1</span>)</span><br><span class="line">            memory[index]=<span class="number">0</span>; <span class="comment">//初始化一个memory</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中用initial语句在仿真开始时对各变量进行初始化。</p>
<p>[例2]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        inputs = <span class="number">&#x27;b000000</span>; <span class="comment">//初始时刻为0</span></span><br><span class="line">        #<span class="number">10</span> inputs = <span class="number">&#x27;b011001</span>; </span><br><span class="line">        #<span class="number">10</span> inputs = <span class="number">&#x27;b011011</span>; </span><br><span class="line">        #<span class="number">10</span> inputs = <span class="number">&#x27;b011000</span>; </span><br><span class="line">        #<span class="number">10</span> inputs = <span class="number">&#x27;b001000</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>从这个例子中，<strong>我们可以看到initial语句的另一用途，即用initial语句来生成激励波形作为电路的测试仿真信号。</strong>一个模块中可以有多个initial块，它们都是并行运行的。</p>
<p><strong>initial块常用于测试文件和虚拟模块的编写，用来产生仿真测试信号和设置信号记录等仿真环境。</strong></p>
<h6 id="1-2-always语句"><a href="#1-2-always语句" class="headerlink" title="1.2 always语句"></a><strong>1.2 always语句</strong></h6><p>always语句在仿真过程中是不断重复执行的。</p>
<p>其声明格式如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> &lt;时序控制&gt;  &lt;语句&gt;</span><br></pre></td></tr></table></figure>

<p>always语句由于其不断重复执行的特性，只有和一定的时序控制结合在一起才有用。如果一个always语句没有时序控制，则这个always语句将会发成一个仿真死锁。见下例：</p>
<p>[例1]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> areg = ~areg;</span><br></pre></td></tr></table></figure>

<p>这个always语句将会生成一个0延迟的无限循环跳变过程，这时<strong>会发生仿真死锁</strong>。如果加上时序控制，则这个always语句将变为一条非常有用的描述语句。见下例：</p>
<p>[例2]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> #<span class="number">10</span>  areg = ~areg;</span><br></pre></td></tr></table></figure>

<p>这个例子生成了一个周期为20 的无限延续的信号波形，常用这种方法来描述时钟信号，作为激励信号来测试所设计的电路。</p>
<p>[例3]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] counter;</span><br><span class="line"><span class="keyword">reg</span> tick;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> areg) </span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        tick = ~tick;</span><br><span class="line">        counter = counter + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这个例子中,每当areg信号的==上升沿==出现时把tick信号反相，并且把counter增加1。这种时间控制是always语句最常用的。</p>
<p>always 的时间控制可以是沿触发也可以是电平触发的，可以单个信号也可以多个信号，中间需要用关键字 or 连接，如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="comment">//由两个沿触发的always块</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span> @( a <span class="keyword">or</span> b <span class="keyword">or</span> c ) <span class="comment">//由多个电平触发的always块</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>沿触发的always块常常描述时序逻辑，如果符合可综合风格要求可用综合工具自动转换为表示时序逻辑的寄存器组和门级逻辑，而电平触发的always块常常用来描述组合逻辑和带锁存器的组合逻辑，如果符合可综合风格要求可转换为表示组合逻辑的门级逻辑或带锁存器的组合逻辑。<strong>一个模块中可以有多个always块，它们都是并行运行的</strong>。</p>
<p><strong>always是一个极高频的语法，always@（）用法总结如下</strong></p>
<p>① always*@(信号名)*</p>
<p>• 信号名有变化就触发事件</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例: </span><br><span class="line"><span class="keyword">always</span>@( clock) </span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure>

<p>② always@( posedge信号名)</p>
<p>• 信号名有上升沿就触发事件</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line"><span class="keyword">always</span>@( <span class="keyword">posedge</span> clock) </span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure>

<p>③ always@(negedge信号名)</p>
<p>• 信号名有下降沿就触发事件</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line"><span class="keyword">always</span>@( <span class="keyword">negedge</span> clock) </span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure>

<p>④ always@(敏感事件1or敏感事件2or…)</p>
<p>• 敏感事件之一触发事件</p>
<p>• 没有其它组合触发</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> reset <span class="keyword">or</span> <span class="keyword">posedge</span> clear) </span><br><span class="line">reg_out=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>⑤ always@(*)</p>
<p>• 无敏感列表，描述组合逻辑，和assign语句是有区别的</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line"><span class="keyword">always</span>@(*) </span><br><span class="line">b= <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure>

<p>assign赋值语句和always@(*)语句。两者之间的差别有：</p>
<p>1.被assign赋值的信号定义为wire型，被always@(*)结构块下的信号定义为reg型，值得注意的是，这里的reg并不是一个真正的触发器，只有敏感列表为上升沿触发的写法才会综合为触发器，在仿真时才具有触发器的特性。</p>
<p>2.另外一个区别则是更细微的差别：举个例子,</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> a;</span><br><span class="line"><span class="keyword">reg</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> a = <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(*)</span><br><span class="line">b= <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，做仿真时a将会正常为0，但是b却是不定态。这是为什么？verilog规定，always@(<em>)中的</em>是指该always块内的所有输入信号的变化为敏感列表，也就是仿真时只有当always@()块内的输入信号产生变化，该块内描述的信号才会产生变化，而像always@() b = 1’b0，这种写法由于1’b0一直没有变化，所以b的信号状态一直没有改变，由于b是组合逻辑输出，所以复位时没有明确的值（不定态），而又因为always@(*)块内没有敏感信号变化，因此b的信号状态一直保持为不定态。事实上该语句的综合结果有可能跟assign一样但是在功能仿真时就差之千里了。</p>
<h5 id="5-编译预处理语句"><a href="#5-编译预处理语句" class="headerlink" title="5.编译预处理语句"></a><strong>5.编译预处理语句</strong></h5><p>Verilog HDL语言和C语言一样也提供了编译预处理的功能。“编译预处理”是Verilog HDL编译系统的一个组成部分。</p>
<p>Verilog HDL语言允许在程序中使用几种特殊的命令(它们不是一般的语句)。Verilog HDL编译系统通常先对这些特殊的命令进行“预处理”，然后将预处理的结果和源程序一起在进行通常的编译处理。</p>
<p>在Verilog HDL语言中，为了和一般的语句相区别，这些预处理命令以符号“ `”开头(注意这个符号是不同于单引号“ ‘”的)。这些预处理命令的有效作用范围为定义命令之后到本文件结束或到其它命令定义替代该命令之处。Verilog HDL提供了以下预编译命令：</p>
<p><code>accelerate，</code>autoexpand_vectornets，<code>celldefine，</code>default_nettype，<code>define，</code>else，<code>endcelldefine，</code>endif，<code>endprotect，</code>endprotected，<code>expand_vectornets，</code>ifdef，<code>include，</code>noaccelerate,<code>noexpand_vectornets，</code>noremove_gatenames，<code>noremove_netnames，</code>nounconnected_drive，<code>protect，</code>protecte，<code>remove_gatenames，</code>remove_netnames，<code>reset,</code>timescale，`unconnected_drive</p>
<p>在这一小节里只对常用的<code>define、</code>include、`timescale进行介绍，其余的请查阅参考书。</p>
<h6 id="1-1-宏定义-define"><a href="#1-1-宏定义-define" class="headerlink" title="1.1 宏定义 `define"></a><strong>1.1 宏定义 `define</strong></h6><p>用一个指定的标识符(即名字)来代表一个字符串，它的一般形式为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> 标识符(宏名) 字符串(宏内容)</span></span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> signal string</span></span><br></pre></td></tr></table></figure>

<p>它的作用是指定用标识符signal来代替string这个字符串，在编译预处理时，把程序中在该命令以后所有的signal都替换成string。</p>
<p>这种方法使用户能以一个简单的名字代替一个长的字符串，也可以用一个有含义的名字来代替没有含义的数字和符号，因此把这个标识符(名字)称为“宏名”，在编译预处理时将宏名替换成字符串的过程称为“宏展开”。`define是宏定义命令。</p>
<p>[例1]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> WORDSIZE 8</span></span><br><span class="line"><span class="keyword">module</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">1</span>:<span class="meta">`WORDSIZE] data; //这相当于定义 reg[1:8] data; </span></span><br></pre></td></tr></table></figure>

<p>关于宏定义的八点说明：</p>
<ol>
<li><p>宏名可以用大写字母表示，也可以用小写字母表示。建议使用大写字母，以与变量名相区别。</p>
</li>
<li><p><code>define命令可以出现在模块定义里面，也可以出现在模块定义外面。宏名的有效范围为定义命令之后到原文件结束。通常，</code>define命令写在模块定义的外面，作为程序的一部分，在此程序内有效。</p>
<p>**3. *<strong>在引用已定义的宏名时，必须在宏名的前面加上符号“`”，表示该名字是一个经过宏定义的名字。</strong></p>
</li>
<li><p>使用宏名代替一个字符串，可以减少程序中重复书写某些字符串的工作量。而且记住一个宏名要比记住一个无规律的字符串容易，这样在读程序时能立即知道它的含义，当需要改变某一个变量时，可以只改变 <code>define命令行，一改全改。如例1中，先定义WORDSIZE代表常量8，这时寄存器data是一个8位的寄存器。如果需要改变寄存器的大小，只需把该命令行改为：</code>define WORDSIZE 16。这样寄存器data则变为一个16位的寄存器。由此可见使用宏定义，可以提高程序的可移植性和可读性。</p>
</li>
<li><p>宏定义是用宏名代替一个字符串，也就是作简单的置换，不作语法检查。预处理时照样代入，不管含义是否正确。只有在编译已被宏展开后的源程序时才报错。</p>
</li>
<li><p><strong>宏定义不是Verilog HDL语句，不必在行末加分号。如果加了分号会连分号一起进行置换。</strong>如：</p>
</li>
</ol>
<p>[例2]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test;</span><br><span class="line"><span class="keyword">reg</span> a, b, c, d, e, out;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> expression a+b+c+d;</span></span><br><span class="line"><span class="keyword">assign</span> out = <span class="meta">`expression + e;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

<p>经过宏展开以后，该语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assign  out = a+b+c+d;+e;</span><br></pre></td></tr></table></figure>

<p>显然出现语法错误。</p>
<p>\7) 在进行宏定义时，可以引用已定义的宏名，可以层层置换。如：</p>
<p>[例3]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test;</span><br><span class="line"><span class="keyword">reg</span> a, b, c;</span><br><span class="line"><span class="keyword">wire</span> out;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> aa a + b</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> cc c + `aa</span></span><br><span class="line"><span class="keyword">assign</span> out = <span class="meta">`cc;</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>这样经过宏展开以后，assign语句为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assign out = c + a + b;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>宏名和宏内容必须在同一行中进行声明。如果在宏内容中包含有注释行，注释行不会作为被置换的内容。如：</li>
</ol>
<p>[例4]:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span></span><br><span class="line"> <span class="meta">`<span class="meta-keyword">define</span> typ_nand nand #5 //<span class="meta-keyword">define</span> a nand with typical delay</span></span><br><span class="line"> <span class="meta">`typ_nand g121(q21,n10,n11);</span></span><br><span class="line"> ………</span><br><span class="line"> <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>经过宏展开以后，该语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nand #5 g121(q21,n10,n11);</span><br></pre></td></tr></table></figure>

<p>宏内容可以是空格，在这种情况下，宏内容被定义为空的。当引用这个宏名时，不会有内容被置换。</p>
<p><strong>注意：组成宏内容的字符串不能够被以下的语句记号分隔开的。</strong></p>
<ul>
<li>· 注释行</li>
<li>· 数字</li>
<li>· 字符串</li>
<li>· 确认符</li>
<li>· 关键词</li>
<li>· 双目和三目字符运算符</li>
</ul>
<p>如下面的宏定义声明和引用是非法的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> first_half &quot;start of string</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="meta">`first_half end of string&quot;);</span></span><br></pre></td></tr></table></figure>

<p>注意在使用宏定义时要注意以下情况：</p>
<ol>
<li>对于某些 EDA软件，在编写源程序时，如使用和预处理命令名相同的宏名会发生冲突，因此建议不要使用和预处理命令名相同的宏名。</li>
</ol>
<ol start="2">
<li>宏名可以是普通的标识符(变量名)。例如signal_name 和 ‘signal_name的意义是不同的。但是这样容易引起混淆，建议不要这样使用。</li>
</ol>
<h6 id="1-2-“文件包含”处理-include"><a href="#1-2-“文件包含”处理-include" class="headerlink" title="1.2 “文件包含”处理`include"></a><strong>1.2 “文件包含”处理`include</strong></h6><p>所谓“文件包含”处理是一个源文件可以将另外一个源文件的全部内容包含进来，即将另外的文件包含到本文件之中。Verilog HDL语言提供了`include命令用来实现“文件包含”的操作。其一般形式为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`include “文件名”</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-6cc2b400531b15d50b7a9913bef18888_720w.jpg" alt="img"></p>
<p>上图表示“文件包含”的含意。图(a)为文件File1.v,它有一个<code>include &quot;File2.v&quot;命令，然后还有其它的内容(以A表示)。图(b)为另一个文件File2.v,文件的内容以B表示。在编译预处理时，要对</code>include命令进行“文件包含”预处理:将File2.v的全部内容复制插入到 `include “File2.v”命令出现的地方，即File2.v 被包含到File1.v中，得到图(c)所示的结果。</p>
<p>在接着往下进行的编译中，将“包含”以后的File1.v作为一个源文件单位进行编译。</p>
<p>“文件包含”命令是很有用的，它可以节省程序设计人员的重复劳动。可以将一些常用的宏定义命令或任务(task)组成一个文件，然后用<code>include命令将这些宏定义包含到自己所写的源文件中，相当于工业上的标准元件拿来使用。另外在编写Verilog HDL源文件时，一个源文件可能经常要用到另外几个源文件中的模块，遇到这种情况即可用</code>include命令将所需模块的源文件包含进来。</p>
<p>[例1]：</p>
<p>(1)文件aaa.v</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> aaa(a,b,out);</span><br><span class="line"><span class="keyword">input</span> a, b;</span><br><span class="line"><span class="keyword">output</span> out;</span><br><span class="line"><span class="keyword">wire</span> out;</span><br><span class="line"><span class="keyword">assign</span> out = a^b;</span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>

<p>(2)文件 bbb.v</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;aaa.v&quot;</span></span><br><span class="line"><span class="keyword">module</span> bbb(c,d,e,out);</span><br><span class="line"><span class="keyword">input</span> c,d,e;</span><br><span class="line"><span class="keyword">output</span> out;</span><br><span class="line"><span class="keyword">wire</span> out_a;</span><br><span class="line"><span class="keyword">wire</span> out;</span><br><span class="line"> aaa aaa(<span class="variable">.a</span>(c),<span class="variable">.b</span>(d),<span class="variable">.out</span>(out_a));</span><br><span class="line"><span class="keyword">assign</span> out=e&amp;out_a;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，文件bbb.v用到了文件aaa.v中的模块aaa的实例器件，通过“文件包含”处理来调用。模块aaa实际上是作为模块bbb的子模块来被调用的。在经过编译预处理后，文件bbb.v实际相当于下面的程序文件bbb.v：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> aaa(a,b,out);</span><br><span class="line">    <span class="keyword">input</span> a, b;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">wire</span> out;</span><br><span class="line">    <span class="keyword">assign</span> out = a ^ b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> bbb( c, d, e, out);</span><br><span class="line">    <span class="keyword">input</span> c, d, e;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">wire</span> out_a;</span><br><span class="line">    <span class="keyword">wire</span> out;</span><br><span class="line">    aaa aaa(<span class="variable">.a</span>(c),<span class="variable">.b</span>(d),<span class="variable">.out</span>(out_a));</span><br><span class="line">    <span class="keyword">assign</span> out= e &amp; out_a;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>关于“文件包含”处理的四点说明：</p>
<ol>
<li><p>一个<code>include命令只能指定一个被包含的文件，如果要包含n个文件，要用n个</code>include命令。</p>
</li>
<li><p>`include命令可以出现在Verilog HDL源程序的任何地方，被包含文件名可以是相对路径名，也可以是绝对路径名。例如：’include”parts/count.v”</p>
</li>
<li><p>可以将多个<code>include命令写在一行，在</code>include命令行，只可以出空格和注释行。例如下面的写法是合法的。</p>
</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;<span class="keyword">include</span> <span class="string">&quot;fileB&quot;</span> &#x27;<span class="keyword">include</span> <span class="string">&quot;fileC&quot;</span> <span class="comment">//including fileB and fileC</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果文件1包含文件2，而文件2要用到文件3的内容，则可以在文件1用两个`include命令分别包含文件2和文件3，而且文件3应出现在文件2之前。例如在下面的例子中，即在file1.v中定义：</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">include</span>&quot;file3.v&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span>&quot;file2.v&quot;</span></span><br><span class="line"><span class="keyword">module</span> test(a,b,out);</span><br><span class="line"><span class="keyword">input</span>[<span class="number">1</span>:<span class="meta">`size2] a, b;</span></span><br><span class="line"><span class="keyword">output</span>[<span class="number">1</span>:<span class="meta">`size2] out;</span></span><br><span class="line"><span class="keyword">wire</span>[<span class="number">1</span>:<span class="meta">`size2] out;</span></span><br><span class="line"><span class="keyword">assign</span> out= a+b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>file2.v的内容为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> size2 `size1+1</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>file3.v的内容为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> size1 4</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>这样，file1.v和file2.v都可以用到file3.v的内容。在file2.v中不必再用 `include “file3.v”了。</p>
<ol start="5">
<li>在一个被包含文件中又可以包含另一个被包含文件，即文件包含是可以嵌套的。例如上面的问题也可以这样处理，见下图，</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-1dc608ff7f1230c4ea140aca8cc363c0_720w.jpg" alt="img"></p>
<p>它的作用和下图的作用是相同的。</p>
<p><img src="https://pic4.zhimg.com/80/v2-223b1018e94087baec1dfb470a9f294f_720w.jpg" alt="img"></p>
<h6 id="1-3时间尺度-timescale"><a href="#1-3时间尺度-timescale" class="headerlink" title="1.3时间尺度 `timescale"></a><strong>1.3时间尺度 `timescale</strong></h6><p>timescale命令用来说明跟在该命令后的模块的时间单位和时间精度。使用`timescale命令可以在同一个设计里包含采用了不同的时间单位的模块。</p>
<p>例如，一个设计中包含了两个模块，其中一个模块的时间延迟单位为ns，另一个模块的时间延迟单位为ps。EDA工具仍然可以对这个设计进行仿真测试。</p>
<p>`timescale 命令的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`timescale&lt;时间单位&gt;/&lt;时间精度&gt;</span><br></pre></td></tr></table></figure>

<p>在这条命令中，时间单位参量是用来定义模块中仿真时间和延迟时间的基准单位的。时间精度参量是用来声明该模块的仿真时间的精确程度的，该参量被用来对延迟时间值进行取整操作(仿真前)，因此该参量又可以被称为取整精度。</p>
<p>如果在同一个程序设计里，存在多个`timescale命令，则用最小的时间精度值来决定仿真的时间单位。另外时间精度至少要和时间单位一样精确，时间精度值不能大于时间单位值。</p>
<p>在`timescale命令中，用于说明时间单位和时间精度参量值的数字必须是整数，其有效数字为1、10、100，单位为秒(s)、毫秒(ms)、微秒(us)、纳秒(ns)、皮秒(ps)、毫皮秒(fs)。这几种单位的意义说明见下表。</p>
<p><img src="https://gitee.com/arrogant-coke/fredcode/raw/master/img/v2-fbbcbef292296619818f392530cbf9bb_720w.jpg" alt="img"></p>
<p>下面举例说明`timescale命令的用法。</p>
<p>[例1]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ps</span></span><br></pre></td></tr></table></figure>

<p>在这个命令之后，模块中所有的时间值都表示是1ns的整数倍。这是因为在<code>timescale命令中，定义了时间单位是1ns。模块中的延迟时间可表达为带三位小数的实型数，因为 </code>timescale命令定义时间精度为1ps.</p>
<p>[例2]：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 10us/100ns</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>timescale命令定义后，模块中时间值均为10us的整数倍。因为</code>timesacle 命令定义的时间单位是10us。延迟时间的最小分辨度为十分之一微秒(100ns)，即延迟时间可表达为带一位小数的实型数。</p>
<p>例3：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">`<span class="meta-keyword">timescale</span> 10ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line"><span class="keyword">reg</span> set;</span><br><span class="line"><span class="keyword">parameter</span> d=<span class="number">1</span><span class="variable">.55</span>;</span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">#d set=<span class="number">0</span>;</span><br><span class="line">#d set=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，`timescale命令定义了模块test的时间单位为10ns、时间精度为1ns。因此在模块test中，所有的时间值应为10ns的整数倍，且以1ns为时间精度。这样经过取整操作，存在参数d中的延迟时间实际是16ns(即1.6×10ns)，这意味着在仿真时刻为16ns时寄存器set被赋值0，在仿真时刻为32ns时寄存器set被赋值1。仿真时刻值是按照以下的步骤来计算的。</p>
<ol>
<li><p>根据时间精度，参数d值被从1.55取整为1.6。</p>
</li>
<li><p>因为时间单位是10ns，时间精度是1ns，所以延迟时间#d作为时间单位的整数倍为16ns。</p>
</li>
<li><p>EDA工具预定在仿真时刻为16ns的时候给寄存器set赋值0(即语句 #d set=0;执行时刻)，在仿真时刻为32ns的时候给寄存器set赋值1(即语句 #d set=1;执行时刻)，</p>
</li>
</ol>
<p><strong>注意：如果在同一个设计里，多个模块中用到的时间单位不同，需要用到以下的时间结构。</strong></p>
<ol>
<li><p>用`timescale命令来声明本模块中所用到的时间单位和时间精度。</p>
</li>
<li><p>用系统任务$printtimescale来输出显示一个模块的时间单位和时间精度。</p>
</li>
<li><p>用系统函数$time和$realtime及%t格式声明来输出显示EDA工具记录的时间信息。</p>
</li>
</ol>
<p>补充：在verilog中#的用法</p>
<p>​    #是延迟的意思，井号后面数字是延迟的数量，延迟的单位由`timescale控制</p>
<p>​    比如有：`timescale 1ns/1ps 意思就是时间单位为1ns，精度是1ps<br>​    那么，#10.5 就是延迟10.5ns的意思<br>​    在同步时序数字逻辑电路的verilog代码中，不能加入“#”进行延迟，这不是代码编写阶段能决定的</p>
<h6 id="1-4-条件编译命令ifdef、else、-endif"><a href="#1-4-条件编译命令ifdef、else、-endif" class="headerlink" title="1.4 条件编译命令ifdef、else、`endif"></a>1.<strong>4 条件编译命令<code>ifdef、</code>else、`endif</strong></h6><p>一般情况下，Verilog HDL源程序中所有的行都将参加编译。但是有时希望对其中的一部分内容只有在满足条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足条件时对一组语句进行编译，而当条件不满足是则编译另一部分。</p>
<p>条件编译命令有以下几种形式：</p>
<p>1)</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifdef</span> 宏名 (标识符)</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">else</span></span></span><br><span class="line">程序段<span class="number">2</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>它的作用是当宏名已经被定义过(用<code>define命令定义)，则对程序段1进行编译，程序段2将被忽略;否则编译程序段2，程序段1被忽略。其中</code>else部分可以没有，即：</p>
<p>2)</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifdef</span> 宏名 (标识符)</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这里的 “宏名” 是一个Verilog HDL的标识符，“程序段”可以是Verilog HDL语句组，也可以是命令行。这些命令可以出现在源程序的任何地方。</p>
<p><strong>注意：被忽略掉不进行编译的程序段部分也要符合Verilog HDL程序的语法规则。</strong></p>
<p>通常在Verilog HDL程序中用到<code>ifdef、</code>else、`endif编译命令的情况有以下几种：</p>
<ul>
<li>· 选择一个模块的不同代表部分。</li>
<li>· 选择不同的时序或结构信息。</li>
<li>· 对不同的EDA工具，选择不同的激励。</li>
</ul>
<h3 id="六-Verilog测试（仿真）文件TestBench如何编写"><a href="#六-Verilog测试（仿真）文件TestBench如何编写" class="headerlink" title="六. Verilog测试（仿真）文件TestBench如何编写"></a>六. Verilog测试（仿真）文件TestBench如何编写</h3><p>一、哪些步骤需要进行仿真</p>
<p>​        下图是FPGA开发的整个流程，先看一下仿真都出现在哪里。<br>流程图中绿色的步骤是要进行测试仿真的，即有三个步骤是要进行仿真操作的（有时会省略“综合后仿真”这一步）</p>
<p>​    <strong>1.RTL仿真</strong><br>​        也称为综合前仿真、前仿真和功能仿真。<br>这一步只验证在顶层模块和功能子模块的设计输入完成后，其电路的逻辑功能是否符合设计要求，不考虑门延时和线延时。</p>
<p>​    <strong>2.综合后仿真</strong><br>​    综合后仿真加入了门延时。</p>
<p>​    <strong>3.时序仿真</strong><br>​    也称为后仿真，在门延时的基础上又加入了线延时。</p>
<p>二、如何编写仿真测试文件</p>
<p>​    下面以功能仿真为例子，说明测试仿真文件如何编写。</p>
<p>​    1.首先准备好需要被测模块的Verilog代码</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> led_twinkle( </span><br><span class="line">	<span class="keyword">input</span> 		 sys_clk ,  <span class="comment">//系统时钟</span></span><br><span class="line">	<span class="keyword">input</span> 		 sys_rst_n, <span class="comment">//系统复位，低电平有效</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] led <span class="comment">//LED 灯</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">	......          <span class="comment">//省略功能部分</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>​    2.编写TestBench测试仿真文件</p>
<p>​     <em>在Vivado软件中，在左侧的 Flow Navigator 窗口点击 Add Source, 选择 Add or create simulation sources，点击 Next，点击 Create     File, 给测试文件命名，通常格式为 “tb被测试模块名”，点击OK，点击Finish。</em></p>
<pre><code> *在 Source 栏中的 Simulation Sources 中双击生成的 “tb_被测试模块名” 文件，进行编写。*
</code></pre>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">~timescale <span class="number">1</span>ns / <span class="number">1</span>ps  <span class="comment">//测试时间基本单位为1ns，精度为1ps</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> tb_led_twinkle(); <span class="comment">//通常起名格式为 tb_被测试模块名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line">	<span class="keyword">reg</span> sys_clk; </span><br><span class="line">	<span class="keyword">reg</span> sys_rst_n; </span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] led;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号初始化，必须有这一步，容易被忽略</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	sys_clk = <span class="number">1&#x27;b0</span>; </span><br><span class="line">	sys_rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	#<span class="number">200</span>  <span class="comment">//延时200ns</span></span><br><span class="line">	sys_rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成时钟，模拟晶振实际的周期时序</span></span><br><span class="line"><span class="keyword">always</span> #<span class="number">10</span> sys_clk = ~sys_clk; <span class="comment">//每10ns，sys_clk进行翻转，达到模拟晶振周期为20ns</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//例化待测模块（模块例化可点击文章最后附上的网址）</span></span><br><span class="line">led_twinkle u_led_twinkle(   </span><br><span class="line">	<span class="variable">.sys_clk</span> (sys_clk),      <span class="comment">//注意语句后面为逗号</span></span><br><span class="line">	<span class="variable">.sys_rst_n</span> (sys_rst_n),</span><br><span class="line">	<span class="variable">.led</span> (led)              <span class="comment">//最后一步无逗号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" data-id="ckys5wjwa0001l8t69ah4es7v" data-title="我的第一篇博客文章" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Verilog/" rel="tag">Verilog</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/01/24/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Verilog/" rel="tag">Verilog</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Verilog/" style="font-size: 10px;">Verilog</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">我的第一篇博客文章</a>
          </li>
        
          <li>
            <a href="/2022/01/24/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>